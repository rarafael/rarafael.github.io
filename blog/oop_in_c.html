<!DOCTYPE html>

<html lang="en">
<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="../style.css">
  <link rel="icon" href="../icon.webp" type="image/gif">
  <title>OOP in C</title>
</head>

<body>
  <h1>OOP in C</h1>
  <p style="font-size:14px;text-align:left;"><a href="../index.html">home</a></p>
  <p style="font-size:14px;text-align:center;">[24/07/2023]</p>
  <p>
    Hey there! In this post I'll try to cover most common use-cases and applications of the object-oriented
    design paradigm in the C programming language. While thought to not be possible (or to be 'hacky'),
    OOP in C is quite pleasant and simple to work with at times, and demonstrates on a lower level how
    some of the ideas behind OOP can be represented.
  </p>

  <p style="font-size:12px;">
    <i>note that to some extent the examples given here are in a mix of pseudo-code and C, and
    will not be able to compile without some adjustments.</i>
  </p>
  <h2>simple implementation</h2>
  <p>
    The first immediate issue is how to represent objects and <a href="https://en.wikipedia.org/wiki/Class_(computer_programming)">classes</a> 
    in C. Since classes are just a data representation that holds all of an object's information, we can 
    translate them into a C <code>struct</code>.
  </p>
  <p>(Methods in C can be served as simple function pointers, of course.)</p>

  <p>
    So a simple object inside of C could look like:
    <code><pre>
typedef struct {
    int x;
    int y;
    int (*add)(Object *self);
} Class;
    </pre></code>
    And <code>add</code> could be implemented and used in such way:
    <code><pre>
int add(Class *self)
{
    return self->x + self->y;
}

Class object = {
    .x = 2;
    .y = 3;
    .add = add;
};

object.add(&object) == 5 /* true */
    </pre></code>
  </p>

  <h2>virtual tables</h2>
  <p>
    You might realize some problems with this if you're midly experienced in C, take this ludicrous
    object for example:
    <code><pre>
typedef struct {
    int x;
    int y;
    int (*function1)(Class *self);
    int (*function2)(Class *self, int args);
    ...
    /* ommited to keep the post readable */
    ...
    int (*function821)(Class *self, char different_arg);
} Class;
    </pre></code>
    Since all the function pointers in the object are being stored in the struct itself, that means
    all objects declared will hold a copy of all function pointers, which increases the size each of
    them takes tremendously. In my x86_64 machine, <code>sizeof(void*)</code> returns 8, which means
    every pointer there is needlessly taking an extra 8 bytes in memory. Amplified for the ridiculous
    example, there is about <b>6kB</b> of unneeded information for every single object. This can be remediated
    by making a <a href="https://en.wikipedia.org/wiki/Virtual_method_table">virtual table</a>.
  </p>

  <p>
    A virtual table holds pointers to the methods, and can then be referenced by the object, i.e.
    <code><pre>
typedef struct ClassVirtualTable {
    int (*add)(Class *self);
} ClassVirtualTable;

typedef struct Class {
    ClassVirtualTable *vtb; /* you'll see later why we're making it */
    int x;                  /* specifically the first member */
    int y;
} Class;
    </pre></code>
    You can then initialize an object pointing to a <code>static</code> ClassVirtualTable, which holds
    all the methods' pointers.
    <code><pre>
int add(Class *self) { return self->x + self->y; }

static ClassVirtualTable global_vtb = {
    .add = add;
};

Class init(int x, int y)
{
    return (Class) { /* look at <a style="background-color:#222;" href="https://en.cppreference.com/w/c/language/compound_literal">compound literals!</a> */
        .vtb = &global_vtb
        .x = x,
        .y = y,
    };
}

Class object_1 = init(2, 3);
Class object_2 = init(4, 8);
Class object_3 = init(2, 0);

object_1.vtb->add(&object_1) == 5  /* true */
object_2.vtb->add(&object_2) == 12 /* true */
object_3.vtb->add(&object_3) == 2  /* true */
    </pre></code>
    In this example, each object initiated only holds a single pointer which holds all functions.
  </p>

  <p>
    If you're attentive with code style, however, you might find that syntax very ugly: <code>object.vtb->add(&object)</code>
    is not pleasing to look at, specially when inside a larger function involving other objects. It would be
    nice if we could have the <code>object.add(&object)</code> syntax while maintaining the virtual table benefits.
    <p>With a bit of C hackiness, we can!</p>
    <code><pre>
Class object = init(2, 3);
ClassVirtualTable **ref = &object.vtb;

(*ref)->add(ref) == 5 /* true */
    </pre></code>
    According to the C standard, a pointer to a struct's first element will always return a pointer to the
    struct itself, therefore <code>ref</code> points to <code>object</code> in this example.
  </p>
  <p>
    This is because of how memory is laid out:
    <code><pre>
+=========================...
# struct data being stored...
+=========================...
     ^               ^
     |               |
+============+ +==========...
# PTR TO VTB # # more data...
+============+ +==========...
^
|
struct's pointer starts here, therefore dereferencing this
dereferences the vtable pointer as well
    </pre></code>
    As long as you keep the vtable struct as the first member, you can use this cleaner syntax.
  </p>

  <h2>encapsulation</h2>
  <p>
    One of the common concepts in OOP is <a href="https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)">encapsulation</a>,
    which resumes to hiding certain data fields from whoemver is calling the function. Making parts of
    the object private allow it to not accessible to future callers, which increase API hardness as any
    changes to the private fields don't trickle down into the user API.
  </p>

  <p>
    The simplest way to implement private fields and encapsulation of objects in C objects is simply by
    naming parts of your object's members as "private", which insinuate to the caller that it should be
    accessible directly. Another option is to use type aware pointers to an incomplete type.
    <p>Take the following code, for example:</p>
    <code><pre>
/* object.h */

typedef struct ClassPrivate ClassPrivate;
typedef struct {
    ClassPrivate *private;
    int x;
    int (*private_stuff)(Class *self);
    void (*destructor)(Class *self);
} Class;

Class init(int x, int y);
    </pre></code>
    <code><pre>
/* object.c */

typedef struct ClassPrivate {
    int y;
} ClassPrivate;

int private_stuff(Class *self) { return self->private->y + self->x; }
void destructor(Class *self) { free(self->private); }

Class init(int x, int y)
{
    ClassPrivate *p = alloc(sizeof(ClassPrivate));
    p->y = y;

    return (Class) {
        .private = p,
        .x = x,
        .private_stuff = private_stuff,
        .destructor = destructor
    };
}
    </pre></code>
    <code><pre>
/* usage.c */

#include "object.h"

Class object = init(2, 3);
/* here, trying to access object.private would trigger UB or
   preferably a compiler error, since the contents of the
   struct are unknown to usage.c */

object.private_stuff(&object) == 5 /* true */
object.destructor(&object);
    </pre></code>
    Additionally, the private parts of the object in this case can be altered without changing the whole
    of the object's size, which otherwise <a href="https://lwn.net/Articles/605607/">has caused problems before</a><br>
  </p>

  <p>
    Such implementation in C, however, adds another usage of dynamic allocation, which has to be freed by the
    caller later through a <code>destructor()</code> method. This can add unecessary complexity to your
    API, as now the caller has to be worried with managing the object's scope. For any non-trivial object,
    however, is inevitable that such destructor be made necessary.<br>
  </p>

  <h2>inheritance</h2>
  <p>
    Another aspect of object-oriented design is that of inheritance, where an object can take aspects of a
    'superclass' while adding and modifying methods. We can take a simple and hypothetical example:
  </p>

  <p>
    Consider an object of class <code>Animal</code> which we want to create a derivative of, called <code>Cat</code>.
    The Animal class contains informations of how many legs the animal has and what is it's average lifespan,
    and contains a method that says how many years it has 'per leg'. The Cat subclass adds a new method called
    <code>meow()</code> that prints out "meow".
    <code><pre>
typedef struct {
    int (*years_per_leg)(AnimalClass *self);
} AnimalClassVirtualTable;

typedef struct {
    AnimalClassVirtualTable *vtb;
    int legs;
    int lifespan;
} AnimalClass;

typedef struct {
    AnimalClass _;
    void (*meow)(CatClass *self);
} CatClass;
    </pre></code>
    Using our previous knowledge of structs presented in the Virtual Tables section, we know that a pointer to
    CatClass's <code>_</code> is going to point to the CatClass struct itself, which means we can apply the following:
    <code><pre>
CatClass cat_object = {
    ._ = (AnimalClass) {
        .vtb = gvtb,
        .legs = 4,
        .lifespan = 16
    },
    .meow = meow_func
};

AnimalClass *cat_animal_object = &cat_object._;

cat_animal_object->vtb->years_per_leg(&cat_animal_object) == 4 /* true */
cat_object.meow(&cat_object) /* "meow" */
    </pre></code>
    And you can even enhance it pointing to AnimalClass' virtual table
    <code><pre>
AnimalClassVirtualTable **ref = &cat_object._.vtb;

(*ref)->years_per_leg(ref) == 4 /* true */
cat_object.meow((CatClass*)ref) /* "meow" */
    </pre></code>
  </p>

  <h2>polymorphism</h2>
  <p>
    <a href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)">Polymorphism</a> in OOP is the
    idea that an implementation of a class can be called on another class and maintain its functionality
    - a generic of sorts for classes. Such functionality can be implemented with C's own <code>_Generic</code>
    preprocessor directive:
    <code><pre>
typedef struct {
    const char *(*add)(StringClass *self, const char *appendee);
    char *string;
} StringClass;

typedef struct {
    int (*add)(NumberClass *self, int addnum);
    int x;
} NumberClass;

const char *string_class_add_impl(StringClass *self, const char *appendee)
{ 
    ... 
    return result;
}
const char *number_class_add_impl(NumberClass *self, int addnum) 
{ 
    ... 
    return result;
}

#define add(A, B) _Generic((A),     \
                StringClass*: string_class_add_impl, \
                NumberClass*: number_class_add_impl  \
                )(A,B)
    </pre></code>
  </p>

  <p>
    This implementation has limitations, such as the scope of both functions needing to be exposed to
    the caller. Another way is to use the vtables we introduced earlier to simplify this process:
    <code><pre>
typedef struct {
    void (*speak)(void);
} CommonClassVirtualTable;

typedef struct {
    CommonClassVirtualTable *vtb;
} CommonClass;

typedef struct {
    CommonClassVirtualTable *vtb;
} CatClass;

typedef struct {
    CommonClassVirtualTable *vtb;
} DogClass;

void cat_speak(void) { print("meow"); }
void dog_speak(void) { print("woof"); }

static CommonClassVirtualTable dog_gvtb = {
    .speak = dog_speak
};

static CommonClassVirtualTable cat_gvtb = {
    .speak = cat_speak
};

CatClass cat_init(void)
{ 
    return (CatClass) { .vtb = &cat_gvtb };
}

DogClass dog_init(void)
{
    return (DogClass) { .vtb = &dog_gvtb };
}

void speak(void *p) /* can take either DogClass or CatClass */
{
    CommonClass *cc_ptr = (CommonClass*)p;
    CommonClassVirtualTable **tmp = &cc_ptr->vtb;
    (*tmp)->speak();
}

CatClass cat_object = cat_init(void);
DogClass dog_object = dog_init(void);

speak(&cat_object); /* "meow" */
speak(&dog_object); /* "woof" */
    </pre></code>
    Note that this takes advantage of the fact that the <code>speak()</code> function is the first
    in both structs, so as long as they share the same virtual table order you should be able to call
    the same functions as they're assigned to their own global vtables.
  </p>

  <h2>conclusion</h2>
    Now we have implemented at least the conceptual base of objects and methods inside of C's idioms!
    I hope this makes some aspects of C's memory layout information and how it can disposed for objects
    clearer :D
  <h2>references:</h2>
  <p>
    <ul style="list-style-type:'- ';">
      <li><a href="https://nullprogram.com/blog/2014/10/21/">Chris Wellons' article on the subject</a>
      <br><code style="font-size:12px;">(his stuff is really good you should read it :D)</code></li>
      <li><a href="https://www.cs.rit.edu/~ats/books/ooc.pdf">"Object-Oriented Programming in ANSI C" by Axel-Tobias Schreiner</a></li>
      <li><a href="https://www.lelanthran.com/chap9/content.html">lelanthran post I found on HN</a></li>
      <li><a href="https://bearssl.org/oop.html">BearSSL's page on how they do OOP in C</a></li>
      <li><a href="https://en.cppreference.com/w/c">cppreference.com: the de facto holder of all C knowledge</a></li>
    </ul>
  </p>
  <h2>concerns:</h2>
  <h3>"Object oriented programming is evil"</h3>
  <p>
    While it is true that many of the paradigms offered by OOP have been overused in certain projects,
    I don't go into the merit of prescribing whether the <i>modus operandi</i> of OOP is inherently bad practice.
  </p>
  <h3>"C is unsafe and you should write new code only in Rust!"</h3>
  <p>
    While it is true that C is a very unsafe languages without guarantees for <i>many</i> things, and that
    relies on it's users ability to remember scope where dynamic allocation is used, there is still an
    argument to be made that it is a fun language to program in. There is also the aspect of ABI stability:
    C is a language that is more than 50 years old, and composes a large part of application libraries and
    backend infrastructure, it is the <i>lingua franca</i> of programming.
  </p>

  <h3>"Why are you doing this when C++/Obj-C/D exists?"</h3>
  <p>
    Besides the fun aspect, I think it is important to demonstrate that such paradigms are not specific to
    a language's support for it's syntax, when in reality they're there only to assist the user in pushing
    out the concepts. Of course its easier to write an object and it's methods in C++ because the language
    has support for all the keywords that let the compiler know what you're trying to do, but it is relevant
    to know what is happening behind the compiler's sheet when you declare a method <code>virtual</code> or
    when you create an inherited object.
  </p>
</body>

<footer>
  <p><a href="../index.html">home</a></p>
</footer>

</html>
